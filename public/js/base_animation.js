// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ENGINE.Base_Animation = (function(_super) {
    __extends(Base_Animation, _super);

    Base_Animation.prototype.lifespan = void 0;

    Base_Animation.prototype.time_passed = 0;

    Base_Animation.prototype.letter = 'X';

    Base_Animation.prototype.mods = [];

    Base_Animation.prototype.type = void 0;

    Base_Animation.get_random_animation = function() {
      var rl;
      rl = _.sample(ENGINE.base_animations);
      return rl;
    };

    function Base_Animation(args) {
      this.get_sphere_mesh = __bind(this.get_sphere_mesh, this);
      this.get_text_mesh = __bind(this.get_text_mesh, this);
      this.add_mod = __bind(this.add_mod, this);
      this.live_longer = __bind(this.live_longer, this);
      this.add_random_modifier = __bind(this.add_random_modifier, this);
      this.apply_mods = __bind(this.apply_mods, this);
      this.has_mods = __bind(this.has_mods, this);
      this.render = __bind(this.render, this);
      this.step = __bind(this.step, this);
      this.time_left = __bind(this.time_left, this);
      this.full_remove = __bind(this.full_remove, this);
      Base_Animation.__super__.constructor.call(this, args);
    }

    Base_Animation.prototype.full_remove = function() {
      ENGINE.threeScene.remove(this.model);
      return this.remove();
    };

    Base_Animation.prototype.time_left = function() {
      return this.lifespan - this.time_passed;
    };

    Base_Animation.prototype.step = function(delta) {
      if (this.time_left() < 0) {
        this.full_remove();
      }
      if (this.time_left() > 0) {
        return this.time_passed += delta;
      }
    };

    Base_Animation.prototype.render = function() {
      if (this.model === void 0) {
        this.model = this.get_text_mesh();
        return ENGINE.threeScene.add(this.model);
      } else {
        return this.apply_mods();
      }
    };

    Base_Animation.prototype.has_mods = function() {
      return this.mods.length > 0;
    };

    Base_Animation.prototype.apply_mods = function() {
      var mod, _i, _len, _ref, _results;
      if (this.has_mods()) {
        _ref = this.mods;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mod = _ref[_i];
          _results.push(mod.apply());
        }
        return _results;
      }
    };

    Base_Animation.prototype.add_random_modifier = function() {
      this.mods.push(new ENGINE.Base_Animation_Mod(this));
      return this;
    };

    Base_Animation.prototype.live_longer = function() {
      var LIVE_LONGER;
      LIVE_LONGER = "ll";
      return this.mods.push(new ENGINE.Base_Animation_Mod(this, LIVE_LONGER));
    };

    Base_Animation.prototype.add_mod = function(mod_name) {
      this.mods.push(new ENGINE.Base_Animation_Mod(this, mod_name));
      return this;
    };

    Base_Animation.prototype.get_text_mesh = function() {
      var materialArray, materialFront, materialSide, randX, randY, randZ, textGeom, textHeight, textMaterial, textMesh, textWidth;
      materialFront = new THREE.MeshBasicMaterial({
        color: 0xffffff
      });
      materialSide = new THREE.MeshBasicMaterial({
        color: 0xdddddd
      });
      materialArray = [materialFront, materialSide];
      textGeom = new THREE.TextGeometry(this.letter, {
        size: 20 + _.random(0, 20),
        height: 20,
        curveSegments: 5,
        font: "helvetiker",
        weight: "normal",
        style: "normal",
        material: 0,
        extrudeMaterial: 1
      });
      textMaterial = new THREE.MeshFaceMaterial(materialArray);
      textMesh = new THREE.Mesh(textGeom, textMaterial);
      textGeom.computeBoundingBox();
      textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
      textHeight = textGeom.boundingBox.max.y - textGeom.boundingBox.min.y;
      textMesh.rotation.x = -Math.PI / 2;
      randX = _.random(-40, 40);
      randY = _.random(0, 10);
      randZ = _.random(-40, 40);
      textMesh.position.set(-0.5 * textWidth + randX, randY, .5 * textHeight + randZ);
      return textMesh;
    };

    Base_Animation.prototype.get_sphere_mesh = function() {
      var geometry, material, mesh, randX, randY, randZ;
      geometry = new THREE.SphereGeometry(30, 32, 16);
      material = new THREE.MeshLambertMaterial({
        color: 0x000088
      });
      mesh = new THREE.Mesh(geometry, material);
      randX = _.random(-40, 40);
      randY = _.random(0, 5);
      randZ = _.random(-40, 40);
      mesh.position.set(randX, randY, randZ);
      return mesh;
    };

    return Base_Animation;

  })(ENGINE.Entity);

}).call(this);
